1. 动态排序参数导致的SQL注入（严重）
在项目的文章查询和搜索功能中，存在一个典型的SQL注入漏洞。该漏洞源于对用户控制的排序参数未经充分验证和过滤，直接拼接到SQL查询语句中。
待办任务：修复Mapper层中的SQL注入漏洞
问题分析：
不安全的参数接收：在ArticleCenterController.java和SearchController.java中，多个API端点（如/api/articles/getall和/api/articles/search）接收sortBy和sortOrder作为字符串类型的请求参数，用于控制查询结果的排序 。
危险的MyBatis语法：在MyBatis的映射文件ArticleMapper.xml中，处理排序的SQL片段使用了${}语法，例如：ORDER BY ${sortBy} ${sortOrder} 。在MyBatis中，${}表示直接的字符串替换，它会将参数值原封不动地拼接到SQL语句中。这与安全的#{}语法（会创建预编译的PreparedStatement并使用参数占位符）有着本质区别。
攻击场景：攻击者可以利用此漏洞执行恶意操作。例如，通过构造一个恶意的sortBy参数值，攻击者可以注入一个子查询。一个简单的盲注攻击载荷如下：
sortBy=id ASC, (SELECT IF(ASCII(SUBSTRING((SELECT password FROM user WHERE username='admin'),1,1))=97, SLEEP(5), 1))
如果管理员密码的第一个字符的ASCII码是97（即'a'），数据库将会延迟5秒响应。通过逐字符猜测，攻击者可以利用时间延迟来窃取数据库中的任意数据，包括用户密码哈希值。
这个漏洞的存在揭示了一个深层次的问题：团队虽然意识到了SQL注入的风险（项目中包含了SqlInjectionUtils.java工具类 ），但未能系统性地应用安全防护措施。开发人员可能错误地认为，像sortBy这样的“结构性”参数是安全的，只会包含合法的列名，从而忽略了对其进行验证。这种依赖于开发者“记住”去应用安全措施的模式是极其脆弱的。一个健壮的安全体系应当是默认安全的，从框架层面防止此类漏洞的发生。  
解决方案：
实施严格的白名单验证：
任务：在ArticleServiceImpl和SearchServiceImpl中，对传入的sortBy参数进行严格的白名单验证。
方案：创建一个允许的列名集合（Set<String>），例如{"created_at", "likes_count", "exposure_count"}。在执行查询前，检查sortBy参数是否位于该集合中。如果不在，则使用一个默认的安全值（如created_at）或直接抛出异常。
Java
// 在Service层实现
private static final Set<String> ALLOWED_SORT_COLUMNS =
    Set.of("created_at", "updated_at", "likes_count", "exposure_count");

public Map<String, Object> getAllArticles(int page, int pageSize, String sortBy, String sortOrder) {
    if (!ALLOWED_SORT_COLUMNS.contains(sortBy)) {
        sortBy = "created_at"; // 使用安全的默认值
    }
    //... 继续执行查询
}
（可选）重构Mapper接口以避免动态拼接：
任务：如果业务逻辑允许，可以考虑重构Mapper，使用<choose>、<when>、<otherwise>等MyBatis动态SQL标签来处理排序，从而完全避免使用${}。
方案：
XML
<select id="getAllArticles" resultType="com.web.model.Article">
  SELECT * FROM articles
  <choose>
    <when test="sortBy == 'likes_count'">
      ORDER BY likes_count ${sortOrder}
    </when>
    <when test="sortBy == 'exposure_count'">
      ORDER BY exposure_count ${sortOrder}
    </when>
    <otherwise>
      ORDER BY created_at ${sortOrder}
    </otherwise>
  </choose>
  LIMIT #{offset}, #{pageSize}
</select>
注意：sortOrder参数同样需要进行白名单验证，只允许ASC和DESC。
3.2. 不安全的密码重置机制（严重）
项目的密码重置功能存在一个致命的逻辑漏洞，它允许任何攻击者在仅知道目标用户名的情況下，无需任何身份验证即可重置该用户的密码，从而完全接管账户。
待办任务：实现基于安全令牌的密码重置流程
问题分析：
AuthController.java中定义了一个/api/reset端点 。其后端实现位于AuthServiceImpl.java中，逻辑如下：
从请求体中接收username和newPassword。
通过authService.findByUsername(username)在数据库中查找用户。
如果用户存在，则直接使用passwordEncoder.encode(newPassword)对新密码进行加密。
调用authService.updateAuth(user)将新密码存入数据库 。
这个流程完全缺失了最关键的一步：身份验证。它没有验证请求发起者是否就是该账户的合法拥有者。这使得攻击变得异常简单：
攻击者只需获取一个有效的用户名（可以通过其他公开接口或猜测获得）。
然后向/api/reset端点发送一个包含该用户名和攻击者自选密码的POST请求。
服务器将立即更新密码，导致合法用户被锁定在自己的账户之外，而攻击者则获得了完全的访问权限。
此漏洞的根源在于，该功能的设计完全从功能实现的角度出发（“提供一个重置密码的API”），而没有进行任何形式的威胁建模或安全设计。开发者没有思考“如果这个API被恶意使用会发生什么？”这一基本安全问题。这表明项目的开发流程中缺乏强制性的安全设计审查环节，可能导致其他功能也存在类似的逻辑漏洞。
不搞邮箱认证和手机认证因为小项目
阶段二：执行重置
前端页面/reset-password接收URL中的令牌。
用户在该页面输入新密码。
前端将新密码和令牌提交到一个新的端点，例如POST /api/password/execute-reset。
后端验证令牌的有效性、时效性，并确保其未被使用过。
验证通过后，根据令牌找到对应的用户ID，更新其密码。
立即使该令牌失效（一次性使用）。
引入必要的组件：
任务：为新流程添加邮件发送服务和安全令牌管理功能。
方案：
在项目中集成JavaMail或使用第三方邮件服务（如SendGrid）来发送密码重置邮件。
使用Redis来存储重置令牌及其过期时间，利用其TTL（Time-To-Live）特性自动处理过期。
3.3. 不安全的文件上传实现（高）
项目的文件上传功能存在多项安全缺陷，使其容易受到恶意文件上传攻击，可能导致远程代码执行（RCE）、跨站脚本（XSS）或拒绝服务（DoS）。
待办任务：重构文件上传逻辑，实施多层防御策略
问题分析：
UploadController.java中的文件上传逻辑  存在以下严重问题，这些问题均违反了OWASP（开放式Web应用程序安全项目）推荐的安全上传指南 ：
依赖不可靠的黑名单验证：validateFile方法通过isDangerousExtension函数检查文件扩展名，这是一个典型的黑名单方法。攻击者可以轻易绕过黑名单，例如使用不常见的但可执行的扩展名、大小写变种、或在文件名末尾添加欺骗性字符（如shell.php.jpg或shell.php%00.jpg）。安全实践要求使用白名单，即只允许一个明确定义的、安全的扩展名列表。
信任客户端提供的Content-Type头：validateAvatarFile方法通过检查contentType.startsWith("image/")来验证头像文件。HTTP请求头中的Content-Type完全由客户端控制，可以被轻易伪造。攻击者可以上传一个PHP脚本，但将Content-Type设置为image/jpeg来绕过此检查。这种漏洞被称为MIME嗅探漏洞 。
缺乏文件内容验证：代码没有对文件内容本身进行任何验证。它不会检查文件的“魔术字节”（文件头部的几个字节，用于标识真实文件类型），也不会使用任何内容扫描库。这意味着一个伪装成图片的可执行文件会被系统接受。
使用原始文件名存储：文件被保存时可能使用了原始文件名，这会引入路径遍历（../../）的风险。即使StorageService内部做了处理，这也是一个不安全的实践。最佳实践是生成一个随机的、不包含任何用户输入的文件名进行存储。
潜在的不安全存储位置：文件存储在由weeb.upload.base-path配置的路径下 。如果该路径被配置在Web服务器的根目录（web root）下，并且服务器配置为可执行上传目录中的脚本文件（如.php, .jsp），那么攻击者一旦成功上传Web Shell，就可以通过URL直接访问并执行它，从而完全控制服务器。安全标准强烈建议将上传文件存储在Web根目录之外的隔离位置 。
这些缺陷共同构成了一个脆弱的防御体系。它仅仅依赖于表面的、易于绕过的检查，而没有建立起纵深防御。一个成功的攻击者可以利用这些漏洞上传一个Web Shell，从而获得对服务器的完全控制。
解决方案：
实施文件类型白名单和内容验证：
任务：废弃黑名单，改为白名单验证，并增加基于文件内容的真实类型检查。
方案：
定义一个严格的允许上传的文件扩展名白名单（例如{"jpg", "png", "gif", "pdf", "docx"}）。
拒绝任何扩展名不在白名单或真实MIME类型与扩展名不符的文件。
对上传文件进行重命名和安全存储：
任务：停止使用原始文件名，并将文件存储在Web根目录之外。
方案：
为每个上传的文件生成一个唯一的、随机的文件名（例如使用UUID），并且不包含任何原始文件名中的信息。
在配置文件中强制要求weeb.upload.base-path指向一个位于Web应用部署目录之外的路径。
当用户需要访问文件时，通过一个专门的控制器端点（例如GET /api/files/download/{fileId}）来提供服务。该端点应先进行权限检查，然后从安全位置读取文件并作为数据流返回给用户，同时设置正确的Content-Disposition头。
粗粒度的访问控制：SecurityConfig.java中的授权规则完全基于URL模式和简单的角色字符串（ROLE_USER, ROLE_ADMIN）。例如，requestMatchers("/admin/**").hasRole("ADMIN")将整个/admin/路径下的所有权限都赋予了管理员。这种模式在应用功能复杂化后会迅速变得难以管理。例如，如果需要一个“内容版主”角色，他可以删除文章但不能删除用户，现有的模型就无法轻易实现。一个真正的RBAC（Role-Based Access Control）模型应该将权限（Permission，如article:delete）与角色（Role）解耦，角色是一系列权限的集合，而用户则被赋予一个或多个角色 。
解决方案：
引入完整的RBAC模型：
任务：重构安全模型，引入权限、角色和用户-角色的多对多关系。
方案：
数据库设计：创建permissions表（如id, name）、roles表（如id, name）以及role_permission和user_role两个中间表。
权限定义：在代码中定义细粒度的权限字符串，例如ARTICLE_CREATE, ARTICLE_DELETE_OWN, ARTICLE_DELETE_ANY, USER_BAN等。
重构SecurityConfig：使用Spring Security的@PreAuthorize或@PostAuthorize注解在方法级别进行权限检查，替代原有的URL匹配。例如：@PreAuthorize("hasAuthority('ARTICLE_DELETE_ANY') or (hasAuthority('ARTICLE_DELETE_OWN') and @articleSecurityService.isOwner(principal, #articleId))")。
创建权限管理后台：开发一个管理员界面，用于创建角色、为角色分配权限以及为用户分配角色。
4.1. 核心实时聊天功能严重缺失
项目在实时通信方面的实现与其在README.md文档中的承诺存在巨大鸿沟。许多被描述为核心特性的功能在当前代码中完全缺失，导致其实际用户体验远未达到“现代化即时通信系统”的标准。

待办任务：实现README.md中承诺的关键实时聊天功能

问题分析：

README.md文件为用户描绘了一幅功能丰富的实时聊天图景，其中包括“打字指示器”、“消息状态 (发送中/已发送/已送达/已读)”、“消息撤回”和“消息反应”等 。这些功能是现代IM应用（如Slack, Discord, WhatsApp）的标配，对营造流畅、自然的交流体验至关重要。  

然而，对WebSocketHandler.java的深入分析表明，当前的WebSocket后端实现极为初级 。它仅能处理三种类型的消息：  

auth：用于用户连接时的身份认证。

chat：用于在用户之间转发基本的文本消息。

heartbeat：用于维持连接的心跳检测。

代码中完全没有处理“用户正在输入”、“消息已送达”、“消息已被阅读”等事件的逻辑，也没有定义相应的WebSocket消息类型。虽然数据库层面存在message_reaction表和is_recalled字段，但这些状态变更并未通过WebSocket进行实时广播，用户无法实时感知这些变化。

这种文档与实现之间的脱节，可能源于团队对实现这些实时功能的复杂性估计不足，尤其是在选择了底层的Netty框架之后。这不仅误导了项目干系人对项目成熟度的判断，也意味着产品的核心竞争力尚未形成。

README.md 实时功能实现情况对比

README.md 承诺功能	实现状态	代码证据/分析 (WebSocketHandler.java)	建议行动
打字指示器	未实现	WebSocketHandler中没有处理"typing"或类似事件的逻辑。	定义TYPING_START和TYPING_STOP WebSocket消息类型，并实现广播逻辑。
消息状态 (已送达/已读)	未实现	WebSocketHandler仅负责转发消息，没有实现消息送达确认和已读回执的协议。	实现客户端到服务器的MESSAGE_DELIVERED和MESSAGE_READ确认消息，并广播给相关方。
消息撤回	部分实现 (非实时)	数据库message表有is_recalled字段，但WebSocketHandler没有广播撤回通知的逻辑。	定义MESSAGE_RECALL WebSocket消息类型，当消息被撤回时，向相关会话的所有客户端广播此事件。
消息反应 (表情等)	部分实现 (非实时)	数据库有message_reaction表，但WebSocketHandler没有广播反应更新的逻辑。	定义MESSAGE_REACTION_UPDATE WebSocket消息类型，当反应变化时，向会话广播更新后的反应状态。
表情包支持	未实现	当前chat消息仅处理简单文本内容，没有对自定义表情或Sticker的支持。	扩展消息内容格式（如JSON），支持emoji或sticker类型，并由客户端进行相应渲染。

Export to Sheets
解决方案：

扩展WebSocket消息协议：

任务：在WsContentType.java或类似常量类中，定义一套完整的消息类型来支持缺失的功能。

方案：至少应添加以下类型：TYPING_START, TYPING_STOP, MESSAGE_DELIVERED, MESSAGE_READ, MESSAGE_RECALL, REACTION_ADD, REACTION_REMOVE。

在WebSocketHandler中实现新事件的处理逻辑：

任务：为每种新的消息类型添加相应的处理逻辑。

方案：

打字指示器：当收到TYPING_START时，向会话中的其他用户广播该事件。收到TYPING_STOP时同理。

已读回执：当用户A收到用户B发送的MESSAGE_READ确认（包含被读消息的ID）时，服务器需要将该事件通知给用户B。

消息撤回/反应：当通过REST API（或WebSocket命令）触发消息撤回或反应变更后，MessageService应通过WebSocketService向该会话的所有在线成员广播一个包含更新信息的消息。

4.2. 缺失标准的协作与社交功能
除了基础的实时通信功能外，项目还缺少一系列在现代协作和社交平台中被视为标准配置的功能。这些功能的缺失，使得WEEB作为一个“团队协作和内容创作”平台，其核心价值大打折扣。

待办任务：规划并实现关键的协作与社交功能

问题分析：

通过对项目代码库的全面审查 ，并与主流协作平台（如Slack）和社交平台（如Discord）的功能集进行对比 ，可以发现以下关键功能的缺失：  

消息线索/回复 (Threads)：在群聊中，针对某一条特定消息进行回复是组织对话、避免信息混乱的核心功能。当前项目数据库的message表中虽然有一个reply_to_message_id字段 ，但这仅能支持简单的引用式回复，无法形成独立的消息线索（Thread），所有回复依然会混杂在主频道中。  

用户提及 (@-mentions)：在群聊中通过@username来特别通知某个成员是协作沟通的基础。当前系统没有实现提及用户的解析、存储和通知机制。

富链接预览 (Link Unfurling)：当用户在聊天中分享一个URL时，现代IM工具会自动抓取该链接的元数据（标题、描述、预览图）并生成一个卡片式预览。此功能可以极大地丰富交流内容，但WEEB目前并未实现。

自定义用户状态：UserOnlineStatus.java中定义的状态仅限于“在线”、“离线”、“离开”、“忙碌”四种 。主流平台允许用户设置自定义状态消息（如“会议中”、“外出就餐”），这为团队成员提供了更丰富的上下文信息。  

这些功能的缺失，表明项目的设计可能更多地停留在“聊天工具”的层面，而未能深入理解“协作平台”或“社区平台”的本质。后者强调的是信息的组织、上下文的保留以及成员之间的高效互动。没有这些功能，WEEB难以在竞争激烈的市场中吸引和留住习惯了丰富交互体验的用户。

解决方案：

实现消息线索功能：

任务：重构消息模型和UI，以支持线程化回复。

方案：

后端：在message表中增加一个thread_id字段。对于一条新的主消息，thread_id可以为其自身的id。所有对该消息的回复，都共享相同的thread_id。

前端：在UI中为每条消息添加“回复”按钮。点击后，打开一个侧边栏或独立的视图，专门显示该thread_id下的所有消息。主聊天窗口中仅显示对主消息的回复数量。

开发用户提及功能：

任务：实现@username的解析、通知和高亮显示。

方案：

前端：在输入框中实现@触发的用户列表自动补全。

后端：在发送消息时，后端需要解析消息内容中的@username，识别出被提及的用户ID。在message表中增加一个字段（如mentioned_user_ids）来存储这些ID。同时，触发NotificationService，为被提及的用户创建一条“您被提及”的通知。

集成链接预览服务：

任务：当消息内容包含URL时，自动生成预览卡片。
方案：当MessageService检测到消息中含有URL时，异步调用一个微服务或后台任务。该任务负责抓取URL内容，解析其HTML中的Open Graph标签（或<title>, <meta name="description">等），并将解析出的标题、描述和图片URL存回message表的一个新JSON字段中（如link_preview_data）。前端根据此数据显示预览卡片。
4.3. 缺乏必要的管理后台与用户安全中心
项目目前完全没有提供任何形式的管理后台或用户安全中心界面。这对于一个计划投入生产环境的平台来说是不可接受的，它意味着系统缺乏有效的管理、监控和用户自助服务能力。
待办任务：开发后台管理系统和用户安全中心
问题分析：
无管理后台 (Admin Panel)：对整个代码库的审查显示，项目中不存在任何用于后台管理的控制器、服务或前端组件 。这意味着所有管理操作，如：  
用户管理：封禁违规用户、重置用户密码、修改用户角色。
内容审核：删除违规文章、评论或消息。
群组管理：解散群组、转移群主。
系统监控：查看用户增长、活跃度、服务器状态等统计数据。
都必须由技术人员直接操作数据库或服务器来完成。这不仅效率低下，而且极易引发操作失误，同时还违反了最小权限原则，因为执行这些操作的人员需要过高的系统权限。
无用户安全中心：用户在个人设置中，除了修改基本资料外，没有任何管理账户安全的选项。主流平台通常会提供一个“安全中心”，允许用户执行以下操作 ：
查看当前所有已登录的会话（包括设备、IP地址、登录时间）。
强制登出所有其他设备。
查看最近的登录历史和安全事件（如密码修改）。
启用/禁用双因素认证（2FA）。
这些功能是建立用户信任、帮助用户在账户疑似被盗时进行自救的关键。
这种缺失反映了典型的“功能优先，运营滞后”的开发模式。团队专注于构建面向最终用户的功能，而完全忽略了系统上线后进行日常运营和维护所必需的工具。这会给未来的运营团队带来巨大的负担，并使用户在面临安全问题时感到无助。
解决方案：
规划并分阶段开发管理后台：
任务：为管理员和运营人员创建一个基于Web的管理后台。
方案
技术选型：可以利用现有的Vue技术栈，创建一个独立的前端应用，或者使用成熟的后台框架（如Vue-Element-Admin）来快速搭建。
API开发：在后端创建一套新的、仅限管理员访问的RESTful API（例如，置于/api/v1/admin/路径下），用于执行用户管理、内容审核等操作。这些API必须受到严格的权限保护（仅ROLE_ADMIN可访问）。
功能优先级：优先开发最核心的管理功能：用户搜索与封禁、内容删除。然后逐步增加角色管理、数据统计报表等高级功能。
在用户设置中增加“安全中心”模块：
任务：为用户提供管理账户安全的功能。
方案：
后端支持：
在Redis中记录用户的活动会话，每个会话包含JWT标识、IP地址、User-Agent和最后活动时间。
提供API端点用于查询当前用户的所有活动会话，以及强制登出特定或所有会话（通过将Redis中的相关JWT加入黑名单）。
使用SecurityAuditUtils记录所有安全敏感操作（登录、密码修改等），并提供API查询这些日志。
前端开发：在用户个人中心页面下，创建一个新的“安全设置”或“账户安全”标签页，用于展示会话列表、登录历史，并提供相应的操作按钮。
V. 代码质量与可维护性问题
本节关注代码库中存在的、影响长期健康发展的问题。这些问题虽然不直接构成安全漏洞或功能缺失，但会增加维护成本、降低开发效率，并可能在未来演变成更严重的缺陷。
5.1. 存在已废弃和冗余的代码
代码库中包含已被明确标记为废弃或已无实际功能的类，这些“僵尸代码”构成了不必要的技术债务，对新加入的开发者造成困扰，并增加了代码库的认知负荷。
待办任务：清理项目中的废弃和冗余代码
问题分析：
功能已移除但代码残留：AiChatService.java被明确标记为@Deprecated，注释中写道“AI聊天功能已彻底移除” 。然而，这个类文件依然存在于项目中。虽然它目前是一个空类，但它的存在会误导开发者，使其认为AI功能可能仍然以某种形式存在或计划回归。
API已更新但旧版并存：如前文所述，ChatListController.java已被@Deprecated注解标记，注释指示应使用新的ChatController 。但该旧控制器并未被禁用或移除，其API端点依然有效。这会造成新开发者在维护或开发新功能时，可能误用旧的、即将被淘汰的API，从而引入缺陷。
这种现象表明团队缺乏严格的代码卫生（Code Hygiene）和重构纪律。一个功能或模块的生命周期不仅包括开发和部署，也应包括在其被取代时的清理和移除。未能完成这最后一步，反映出一种“只增不减”的开发文化，长此以往，项目将变得臃肿不堪，充满了无人理解和不敢触碰的“历史遗留代码”。
解决方案：
执行代码清理计划：
任务：在下一次迭代中，分配专门的时间来清理已知的废弃代码。
方案：
安全移除AiChatService.java：全局搜索项目中对AiChatService的引用。由于它是一个空类，很可能没有实际引用。确认无引用后，直接从版本控制中删除该文件。
安全移除ChatListController.java：
首先，在控制器层面禁用其所有端点，例如通过注释掉@RestController注解或在SecurityConfig中明确拒绝访问其路径。
部署此变更后，监控API网关或服务器日志，确认在一段时间内（例如一到两周）没有任何对旧端点的调用。
确认无调用后，从版本控制中删除ChatListController.java及其相关的服务和DTO（如果它们也仅为该控制器服务）。
5.2. 异常处理机制不一致
项目虽然引入了全局异常处理器这一良好实践，但在具体的控制器实现中却未能统一遵循，存在大量手动的、重复的异常捕获逻辑，这破坏了代码的一致性和可维护性。
待办任务：统一异常处理逻辑，充分利用全局异常处理器
问题分析：
项目中存在一个GlobalExceptionHandler.java文件，它使用了@RestControllerAdvice注解 。这是一个Spring MVC的高级功能，旨在集中捕获应用程序中所有控制器抛出的异常，并将其转换为统一的、标准化的HTTP响应（在本项目中是ApiResponse对象）。这是一种非常好的设计，能够将业务逻辑与错误处理逻辑解耦。  
然而，在AuthController.java等控制器中，大量的方法内部包含了try-catch (RuntimeException e)块 。在catch块中，代码手动构建了一个ResponseEntity<ApiResponse>错误响应并返回，例如：
return ResponseEntity.badRequest().body(ApiResponse.error(1, e.getMessage()));
这种做法完全违背了使用@RestControllerAdvice的初衷，并导致了以下问题：
代码冗余：每个控制器方法中都重复着几乎相同的try-catch模板代码。
不一致的错误响应：手动构建的错误响应可能与GlobalExceptionHandler中定义的格式、状态码或消息结构不完全一致。
信息泄露风险：直接将e.getMessage()返回给客户端，可能会泄露系统内部的实现细节或敏感信息，为攻击者提供线索。GlobalExceptionHandler通常会记录详细的内部错误，但只向客户端返回一个通用的、安全的消息。
这种现象通常被称为“货物崇拜编程”（Cargo Cult Programming）：开发团队引入了一个先进的模式（全局异常处理），但并未完全理解其工作原理和设计哲学，因此仍然沿用着旧的、在每个方法中手动处理异常的习惯。这导致一个本应简化代码、提升健壮性的优秀特性被 фактически架空。
解决方案：
重构所有控制器，移除手动异常处理：
任务：审查项目中所有的@RestController，移除方法内部的try-catch块，让异常自然地向上抛出。
方案：将控制器方法简化，专注于业务逻辑调用。例如，将以下代码：
Java
// AuthController.java (修改前)
@PostMapping("/login")
public ResponseEntity<ApiResponse<Map<String, String>>> login(@RequestBody @Valid LoginVo loginVo) {
    try {
        String token = authService.login(loginVo.getUsername(), loginVo.getPassword());
        Map<String, String> data = new HashMap<>();
        data.put("token", token);
        return ResponseEntity.ok(ApiResponse.success(data));
    } catch (RuntimeException e) {
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(ApiResponse.error(1, e.getMessage()));
    }
}
重构为：
Java
// AuthController.java (修改后)
@PostMapping("/login")
public ApiResponse<Map<String, String>> login(@RequestBody @Valid LoginVo loginVo) {
    String token = authService.login(loginVo.getUsername(), loginVo.getPassword());
    Map<String, String> data = new HashMap<>();
    data.put("token", token);
    return ApiResponse.success(data);
}
在AuthService.login方法中，如果验证失败，应抛出特定的自定义异常（例如AuthenticationFailedException），而不是通用的RuntimeException。
增强GlobalExceptionHandler：
任务：在GlobalExceptionHandler中为业务相关的自定义异常添加专门的处理方法。
方案：为不同的业务场景创建具体的、继承自RuntimeException的异常类，如UserNotFoundException, InvalidPasswordException, AccountLockedException等。然后在GlobalExceptionHandler中为这些异常编写对应的@ExceptionHandler方法，返回更精确的HTTP状态码和错误信息。
Java
// GlobalExceptionHandler.java (增强后)
@ExceptionHandler(InvalidPasswordException.class)
public ResponseEntity<ApiResponse<Object>> handleInvalidPasswordException(InvalidPasswordException e) {
    //... 记录日志
    return new ResponseEntity<>(ApiResponse.unauthorized("用户名或密码错误"), HttpStatus.UNAUTHORIZED);
}
@ExceptionHandler(AccountLockedException.class)
public ResponseEntity<ApiResponse<Object>> handleAccountLockedException(AccountLockedException e) {
    //... 记录日志
    return new ResponseEntity<>(ApiResponse.forbidden("账户已被锁定"), HttpStatus.FORBIDDEN);
}
通过以上重构，可以确保所有异常都由一个中心点统一处理，从而简化控制器代码，保证错误响应的一致性，并提高系统的整体安全性和可维护性。