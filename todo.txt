本项目是一个前后端分离的应用, 前端使用Vue 3.5.13, 后端使用Java Spring Boot 3.5.4.
核心设计理念是分层清晰, 职责单一, 接口标准化, 高内聚低耦合.
项目采用微服务架构思想，包含即时通信、内容管理、文件分享、AI对话等核心功能模块.
所有开发人员必须严格遵守本规范，并且写不完的请写在todo.txt中，写出哪个文件和模块和功能没实现，具体要怎么实现

=== 端口配置规范 ===
1. 后端API服务端口：8080 (application.yml中配置)
2. WebSocket服务端口：8081 (application.yml中配置)
3. 前端开发服务器默认端口：5173 (Vite默认)
4. 严禁随意修改端口配置，如需修改必须更新所有相关文件
5. 修改端口后必须同步更新axiosInstance.js中的API基础URL
6. 端口冲突时优先处理占用端口的进程，而不是修改应用端口

=== 后端开发规范 ===
1. 项目使用MySQL 8.0+数据库和MyBatis-Plus 3.5.8持久层框架
2. 后端遵循多层架构模型, 数据流向为 Controller, Service, Mapper, Database
3. Controller层是API的入口, 负责接收HTTP请求, 使用@Valid注解校验参数, 并调用Service层
4. Controller层严禁编写复杂业务逻辑, 所有接口返回ResponseEntity<ApiResponse<T>>
5. 接收请求必须使用com.web.vo包下的VO对象封装请求体
6. Service层采用接口加实现的设计模式, 接口位于com.web.service包, 实现位于com.web.service.Impl包
7. 涉及多张表读写的复杂数据库操作, 必须在ServiceImpl的方法上使用@Transactional注解
8. 修改ServiceImpl中的方法签名, 必须立即同步更新其对应的Service接口
9. Mapper层采用接口加XML的方式, Mapper接口位于com.web.mapper包, XML文件位于resources/Mapper目录
10. Mapper接口的方法名必须与XML中statement的id一致, @Param注解的参数名必须与XML中的引用严格匹配
11. 新增功能模块必须包含完整的Controller、Service、ServiceImpl、Mapper、VO、Model结构
12. AI相关功能统一使用AiChatService，遵循统一的AI接口规范
13. SSH终端功能统一通过CommandManager管理，确保安全性和可追踪性
14. 文件上传功能必须通过FileService和FileManagementService，确保文件安全检查

=== 数据库规范 ===
1. 位于com.web.model包的实体类与数据库表一一对应
2. User表和UserStats表的分离设计是为了避免高并发下的写锁竞争
3. User表存储低频更新信息, UserStats表存储高频更新的统计信息
4. DatabaseInitializer.java会在非生产环境自动创建库和表
5. user表和user_stats表分离是关键性能设计, 开发涉及用户统计数据的功能时, 必须操作user_stats表
6. 业务逻辑错误应抛出自定义的WeebException
7. GlobalExceptionHandler会统一捕获异常并以标准化的ApiResponse格式返回给前端

=== 前端开发规范 ===
1. 前端所有HTTP通信必须通过src/api/axiosInstance.js中封装的axios实例
2. 请求拦截器会自动添加JWT到请求头, 响应拦截器统一处理ApiResponse格式
3. 新的API请求应根据业务领域添加到src/api/modules/目录下的对应模块中
4. 全局状态管理必须使用Pinia, 用户的认证信息由src/stores/authStore.js管理
5. 新功能模块应在src/stores/目录下创建独立的Store文件
6. UI组件库统一使用Element Plus 2.7.8, 全局样式使用src/assets/apple-style.css中定义的CSS变量
7. 所有页面路由在src/router/index.js中定义, 需要认证的页面应添加meta, { requiresAuth: true }
8. 富文本编辑功能统一使用Quill 2.0.3，遵循统一的编辑器配置规范
9. 视频播放功能统一使用video组件，确保跨浏览器兼容性
10. 新增页面组件必须包含响应式设计，支持移动端适配
11. 组件命名必须使用PascalCase，文件名与组件名保持一致

=== WebSocket开发规范 ===
1. WebSocket连接使用chatStore.js管理, 连接地址: ws://localhost:8081/ws
2. 消息格式必须标准化, 包含type、data、timestamp字段
3. 实时消息同步通过WebSocket实现, HTTP作为备用方案
4. 打字指示器和消息状态通过WebSocket实时传输
5. WebSocket断线重连机制已在chatStore中实现, 不得随意修改

=== 搜索功能规范 ===
1. 消息搜索使用Elasticsearch, 通过SearchController提供API
2. 搜索API路径必须以/api/search/开头
3. 支持多类型搜索: messages、users、groups、articles、all
4. 搜索结果必须包含list和total字段, 支持分页
5. Elasticsearch不可用时, 搜索功能应优雅降级, 不影响核心功能

=== 安全开发规范 ===
1. 所有用户输入必须通过ValidationUtils验证
2. SQL注入防护使用SqlInjectionUtils, 严禁直接拼接SQL
3. 安全事件通过SecurityAuditUtils记录, 包括登录失败、异常操作等
4. JWT Token管理通过authStore.js, 过期自动刷新
5. 敏感信息必须使用环境变量配置, 不得硬编码
6.禁止使用select * 等操作

=== 本地开发健康规范 ===
1. 开发环境启动前必须确保MySQL、Redis、Elasticsearch服务正常运行
2. 数据库连接失败时优先检查服务状态和网络连接，避免频繁修改配置
3. 使用mvn spring-boot:run启动后端，使用npm run dev启动前端
4. 定期清理日志文件，避免日志文件过大影响开发环境性能
5. 本地开发时启用调试模式，设置环境变量DEBUG=true
6. Git提交前必须执行代码格式化和静态检查
7. 开发过程中遇到问题优先查看控制台日志和错误信息
8. 定期更新依赖包版本，确保安全性和性能
9. 开发完成后必须进行基础功能测试，确保核心功能正常
10. 遵循Git Flow工作流，feature分支开发完成后及时合并到develop分支

=== 文档更新规范 ===
1. 修改重要功能后必须同步更新README.md
2. API接口变更必须更新文档中的接口列表
3. 端口配置变更必须更新README.md中的访问应用部分
4. 新增功能必须更新README.md中的核心功能部分
5. 技术架构变更必须更新README.md中的技术栈部分
6. 依赖版本变更必须同步更新README.md中的技术栈信息
7. 新增开发规范必须更新rule.txt文件
8. 项目结构变更必须更新README.md中的项目结构说明

=== 代码修改禁止事项 ===
1. 严禁随意修改端口配置而不更新相关文件
2. 严禁绕过安全验证和输入检查
3. 严禁直接在Controller层编写复杂业务逻辑
4. 严禁不使用事务进行多表操作
5. 严禁不通过统一的API封装进行HTTP请求
6. 严禁修改核心架构设计模式
7. 严禁提交包含安全隐患的代码

=== 项目未来健康规范 ===
1. 保持代码质量和架构清晰
2. 建立完整的CI/CD流程，自动化测试和部署
3. 建立完整的错误追踪和日志分析体系
4. 定期进行代码审查，确保代码质量和规范性
5. 建立完整的项目文档，包括技术文档、用户文档、运维文档
6. 关注系统可扩展性，为未来功能扩展预留接口和架构空间

=== 违规处理 ===
1. 违反核心架构规范的代码将被拒绝合并
2. 不更新文档的功能将被要求补充文档
3. 安全漏洞代码将被立即要求修复
4. 多次违反规范的开发者将被移除提交权限
5. 不遵守本地开发健康规范的将被要求整改
6. 代码质量不达标的将被要求重构和优化
7. 影响系统稳定性的变更将被立即回滚
8. 未经过充分测试的功能将被禁止部署到生产环境

=== 前端功能待实现清单 ===

鉴于后端API已基本完善，但前端界面严重缺失，按照rule.txt规范要求，现将所有缺失的前端功能详细列出：

1. **密码重置页面**（严重缺失）
   文件路径：Vue/src/views/ResetPassword.vue
   功能描述：实现基于安全令牌的密码重置流程前端界面
   具体需求：
   - 从URL参数中获取重置令牌
   - 验证令牌有效性和时效性
   - 提供新密码输入表单（需确认密码）
   - 调用/api/password/execute-reset接口
   - 处理令牌失效、密码强度验证等错误情况
   - 成功后跳转到登录页面

2. **管理员管理后台界面**（严重缺失）
   文件路径：Vue/src/views/admin/目录下创建多个组件
   功能描述：完整的后台管理界面，支持权限、角色、用户管理
   具体需求：
   - Vue/src/views/admin/PermissionManagement.vue - 权限管理页面
   - Vue/src/views/admin/RoleManagement.vue - 角色管理页面
   - Vue/src/views/admin/UserManagement.vue - 用户管理页面
   - Vue/src/views/admin/SystemStatistics.vue - 系统统计页面
   - Vue/src/views/admin/SystemLogs.vue - 系统日志页面
   - Vue/src/views/admin/Dashboard.vue - 管理后台首页
   - 集成Element Plus表格、表单、分页组件
   - 调用对应的AdminController API接口

3. **用户安全中心界面**（严重缺失）
   文件路径：Vue/src/views/SecurityCenter.vue
   功能描述：用户账户安全管理界面
   具体需求：
   - 会话管理：显示活跃会话列表，支持强制登出
   - 登录历史：显示最近登录记录和安全事件
   - 两因素认证：启用/禁用2FA，显示二维码和备用码
   - 密码修改：当前密码验证和新密码设置
   - 安全评分：显示账户安全评分和改进建议
   - 权限查看：显示用户拥有的权限和角色
   - 调用SecurityController的各个API接口

4. **聊天页面的高级功能UI**（功能缺失）
   文件路径：Vue/src/Chat/ChatPage.vue（需要大幅扩展）
   功能描述：实现现代IM应用的核心UI交互
   具体需求：
   - 打字指示器：在聊天输入框下方显示"XXX正在输入..."
   - 消息状态指示：显示消息发送状态（发送中/已发送/已送达/已读）
   - 消息反应系统：点击消息显示表情选择器，支持添加/移除反应
   - 消息撤回功能：右键菜单或悬停显示撤回选项
   - 表情包支持：集成emoji选择器，支持自定义表情
   - 富文本消息：支持格式化文本、链接预览等

5. **协作与社交功能UI**（功能缺失）
   文件路径：Vue/src/Chat/components/目录下创建新组件
   功能描述：现代协作平台的标准功能界面
   具体需求：
   - Vue/src/Chat/components/MessageThread.vue - 消息线索组件
   - Vue/src/Chat/components/UserMention.vue - 用户提及高亮组件
   - Vue/src/Chat/components/LinkPreview.vue - 富链接预览组件
   - Vue/src/Chat/components/CustomStatus.vue - 自定义状态组件
   - 消息线索：点击"回复"按钮创建线索，侧边栏显示线索内容
   - 用户提及：在输入@时显示用户列表，支持键盘导航选择
   - 富链接预览：自动识别URL，显示标题、描述、缩略图
   - 自定义状态：用户可设置自定义状态消息和图标

6. **搜索页面的高级过滤UI**（功能缺失）
   文件路径：Vue/src/search/SearchPage.vue（需要扩展）
   功能描述：支持多维度搜索过滤的界面
   具体需求：
   - 高级搜索表单：分类筛选、作者筛选、日期范围等
   - 搜索结果展示：分页、排序、筛选标签显示
   - 搜索历史：最近搜索关键词和筛选条件保存
   - 搜索建议：热门搜索关键词和相关搜索提示
   - 调用新增的高级搜索API接口

7. **用户资料页面的扩展功能**（功能缺失）
   文件路径：Vue/src/auth/UserProfile.vue（需要扩展）
   功能描述：完整的用户资料展示和管理界面
   具体需求：
   - 个人资料编辑：头像上传、信息修改、隐私设置
   - 统计数据展示：文章数、粉丝数、点赞数等图表展示
   - 关注功能：关注/取消关注用户，关注列表管理
   - 收藏管理：收藏的文章列表，分页展示和管理
   - 活动历史：用户的最近活动和成就展示

8. **全局组件和工具**（基础设施缺失）
   文件路径：Vue/src/components/目录下
   功能描述：支撑上述功能的基础组件库
   具体需求：
   - Vue/src/components/EmojiPicker.vue - 表情选择器组件
   - Vue/src/components/MessageStatus.vue - 消息状态指示器
   - Vue/src/components/UserMention.vue - 用户提及高亮组件
   - Vue/src/components/LinkPreview.vue - 链接预览卡片组件
   - Vue/src/components/SecurityScore.vue - 安全评分显示组件
   - Vue/src/components/PermissionBadge.vue - 权限标签组件
   - Vue/src/components/RoleSelector.vue - 角色选择器组件

9. **状态管理和数据流**（架构缺失）
   文件路径：Vue/src/stores/目录下
   功能描述：前端状态管理和数据处理逻辑
   具体需求：
   - Vue/src/stores/securityStore.js - 安全中心状态管理
   - Vue/src/stores/adminStore.js - 后台管理状态管理
   - Vue/src/stores/chatStore.js - 聊天功能增强（已有需扩展）
   - Vue/src/stores/searchStore.js - 搜索功能状态管理
   - 集成Pinia状态管理，实现组件间数据共享

10. **路由和导航更新**（配置缺失）
    文件路径：Vue/src/router/index.js（需要扩展）
    功能描述：添加新页面的路由配置
    具体需求：
    - 添加管理员后台路由（需管理员权限验证）
    - 添加安全中心路由（需登录验证）
    - 添加密码重置路由（公开访问）
    - 更新导航菜单，支持管理员入口和安全中心入口

11. **国际化支持**（功能缺失）
    文件路径：Vue/src/locales/目录下
    功能描述：多语言支持（英文、中文等）
    具体需求：
    - 创建语言包文件：en.js, zh.js等
    - 集成vue-i18n插件
    - 支持语言切换组件
    - 覆盖所有新功能页面的文案

12. **响应式设计优化**（体验缺失）
    文件路径：所有新创建的Vue组件
    功能描述：移动端适配和响应式布局
    具体需求：
    - 使用Element Plus响应式栅格系统
    - 移动端友好的交互设计
    - 触摸设备的手势支持
    - 小屏幕设备的布局优化

所有前端功能必须严格遵守rule.txt中的规范：
- 使用Element Plus 2.7.8组件库
- 通过src/api/axiosInstance.js进行HTTP通信
- 使用Pinia进行状态管理
- 组件命名使用PascalCase
- 支持移动端响应式设计
- 集成富文本编辑器Quill 2.0.3（用于需要编辑的页面）

前端开发预计工作量：
- 基础页面框架：约15-20个Vue组件文件
- 状态管理：约5个Pinia store文件
- API集成：约8个新的API模块文件
- 样式定制：约2000+行CSS代码
- 国际化：约1000+条翻译文案

建议开发优先级：
1. 密码重置页面（安全漏洞修复）
2. 用户安全中心（用户安全需求）
3. 管理员管理后台（系统管理需求）
4. 聊天高级功能（核心体验提升）
5. 协作功能（平台价值提升）
任务列表
1. 动态排序参数导致的SQL注入（严重）
在项目的文章查询和搜索功能中，存在一个典型的SQL注入漏洞。该漏洞源于对用户控制的排序参数未经充分验证和过滤，直接拼接到SQL查询语句中。
待办任务：修复Mapper层中的SQL注入漏洞
问题分析：
不安全的参数接收：在ArticleCenterController.java和SearchController.java中，多个API端点（如/api/articles/getall和/api/articles/search）接收sortBy和sortOrder作为字符串类型的请求参数，用于控制查询结果的排序 。
危险的MyBatis语法：在MyBatis的映射文件ArticleMapper.xml中，处理排序的SQL片段使用了${}语法，例如：ORDER BY ${sortBy} ${sortOrder} 。在MyBatis中，${}表示直接的字符串替换，它会将参数值原封不动地拼接到SQL语句中。这与安全的#{}语法（会创建预编译的PreparedStatement并使用参数占位符）有着本质区别。
攻击场景：攻击者可以利用此漏洞执行恶意操作。例如，通过构造一个恶意的sortBy参数值，攻击者可以注入一个子查询。一个简单的盲注攻击载荷如下：
sortBy=id ASC, (SELECT IF(ASCII(SUBSTRING((SELECT password FROM user WHERE username='admin'),1,1))=97, SLEEP(5), 1))
如果管理员密码的第一个字符的ASCII码是97（即'a'），数据库将会延迟5秒响应。通过逐字符猜测，攻击者可以利用时间延迟来窃取数据库中的任意数据，包括用户密码哈希值。
这个漏洞的存在揭示了一个深层次的问题：团队虽然意识到了SQL注入的风险（项目中包含了SqlInjectionUtils.java工具类 ），但未能系统性地应用安全防护措施。开发人员可能错误地认为，像sortBy这样的“结构性”参数是安全的，只会包含合法的列名，从而忽略了对其进行验证。这种依赖于开发者“记住”去应用安全措施的模式是极其脆弱的。一个健壮的安全体系应当是默认安全的，从框架层面防止此类漏洞的发生。  
解决方案：
实施严格的白名单验证：
任务：在ArticleServiceImpl和SearchServiceImpl中，对传入的sortBy参数进行严格的白名单验证。
方案：创建一个允许的列名集合（Set<String>），例如{"created_at", "likes_count", "exposure_count"}。在执行查询前，检查sortBy参数是否位于该集合中。如果不在，则使用一个默认的安全值（如created_at）或直接抛出异常。
Java
// 在Service层实现
private static final Set<String> ALLOWED_SORT_COLUMNS =
    Set.of("created_at", "updated_at", "likes_count", "exposure_count");

public Map<String, Object> getAllArticles(int page, int pageSize, String sortBy, String sortOrder) {
    if (!ALLOWED_SORT_COLUMNS.contains(sortBy)) {
        sortBy = "created_at"; // 使用安全的默认值
    }
    //... 继续执行查询
}
（可选）重构Mapper接口以避免动态拼接：
任务：如果业务逻辑允许，可以考虑重构Mapper，使用<choose>、<when>、<otherwise>等MyBatis动态SQL标签来处理排序，从而完全避免使用${}。
方案：
XML
<select id="getAllArticles" resultType="com.web.model.Article">
  SELECT * FROM articles
  <choose>
    <when test="sortBy == 'likes_count'">
      ORDER BY likes_count ${sortOrder}
    </when>
    <when test="sortBy == 'exposure_count'">
      ORDER BY exposure_count ${sortOrder}
    </when>
    <otherwise>
      ORDER BY created_at ${sortOrder}
    </otherwise>
  </choose>
  LIMIT #{offset}, #{pageSize}
</select>
注意：sortOrder参数同样需要进行白名单验证，只允许ASC和DESC。
3.2. 不安全的密码重置机制（严重）
项目的密码重置功能存在一个致命的逻辑漏洞，它允许任何攻击者在仅知道目标用户名的情況下，无需任何身份验证即可重置该用户的密码，从而完全接管账户。
待办任务：实现基于安全令牌的密码重置流程
问题分析：
AuthController.java中定义了一个/api/reset端点 。其后端实现位于AuthServiceImpl.java中，逻辑如下：
从请求体中接收username和newPassword。
通过authService.findByUsername(username)在数据库中查找用户。
如果用户存在，则直接使用passwordEncoder.encode(newPassword)对新密码进行加密。
调用authService.updateAuth(user)将新密码存入数据库 。
这个流程完全缺失了最关键的一步：身份验证。它没有验证请求发起者是否就是该账户的合法拥有者。这使得攻击变得异常简单：
攻击者只需获取一个有效的用户名（可以通过其他公开接口或猜测获得）。
然后向/api/reset端点发送一个包含该用户名和攻击者自选密码的POST请求。
服务器将立即更新密码，导致合法用户被锁定在自己的账户之外，而攻击者则获得了完全的访问权限。
此漏洞的根源在于，该功能的设计完全从功能实现的角度出发（“提供一个重置密码的API”），而没有进行任何形式的威胁建模或安全设计。开发者没有思考“如果这个API被恶意使用会发生什么？”这一基本安全问题。这表明项目的开发流程中缺乏强制性的安全设计审查环节，可能导致其他功能也存在类似的逻辑漏洞。
不搞邮箱认证和手机认证因为小项目
阶段二：执行重置
前端页面/reset-password接收URL中的令牌。
用户在该页面输入新密码。
前端将新密码和令牌提交到一个新的端点，例如POST /api/password/execute-reset。
后端验证令牌的有效性、时效性，并确保其未被使用过。
验证通过后，根据令牌找到对应的用户ID，更新其密码。
立即使该令牌失效（一次性使用）。
引入必要的组件：
任务：为新流程添加邮件发送服务和安全令牌管理功能。
方案：
在项目中集成JavaMail或使用第三方邮件服务（如SendGrid）来发送密码重置邮件。
使用Redis来存储重置令牌及其过期时间，利用其TTL（Time-To-Live）特性自动处理过期。
3.3. 不安全的文件上传实现（高）
项目的文件上传功能存在多项安全缺陷，使其容易受到恶意文件上传攻击，可能导致远程代码执行（RCE）、跨站脚本（XSS）或拒绝服务（DoS）。
待办任务：重构文件上传逻辑，实施多层防御策略
问题分析：
UploadController.java中的文件上传逻辑  存在以下严重问题，这些问题均违反了OWASP（开放式Web应用程序安全项目）推荐的安全上传指南 ：
依赖不可靠的黑名单验证：validateFile方法通过isDangerousExtension函数检查文件扩展名，这是一个典型的黑名单方法。攻击者可以轻易绕过黑名单，例如使用不常见的但可执行的扩展名、大小写变种、或在文件名末尾添加欺骗性字符（如shell.php.jpg或shell.php%00.jpg）。安全实践要求使用白名单，即只允许一个明确定义的、安全的扩展名列表。
信任客户端提供的Content-Type头：validateAvatarFile方法通过检查contentType.startsWith("image/")来验证头像文件。HTTP请求头中的Content-Type完全由客户端控制，可以被轻易伪造。攻击者可以上传一个PHP脚本，但将Content-Type设置为image/jpeg来绕过此检查。这种漏洞被称为MIME嗅探漏洞 。
缺乏文件内容验证：代码没有对文件内容本身进行任何验证。它不会检查文件的“魔术字节”（文件头部的几个字节，用于标识真实文件类型），也不会使用任何内容扫描库。这意味着一个伪装成图片的可执行文件会被系统接受。
使用原始文件名存储：文件被保存时可能使用了原始文件名，这会引入路径遍历（../../）的风险。即使StorageService内部做了处理，这也是一个不安全的实践。最佳实践是生成一个随机的、不包含任何用户输入的文件名进行存储。
潜在的不安全存储位置：文件存储在由weeb.upload.base-path配置的路径下 。如果该路径被配置在Web服务器的根目录（web root）下，并且服务器配置为可执行上传目录中的脚本文件（如.php, .jsp），那么攻击者一旦成功上传Web Shell，就可以通过URL直接访问并执行它，从而完全控制服务器。安全标准强烈建议将上传文件存储在Web根目录之外的隔离位置 。
这些缺陷共同构成了一个脆弱的防御体系。它仅仅依赖于表面的、易于绕过的检查，而没有建立起纵深防御。一个成功的攻击者可以利用这些漏洞上传一个Web Shell，从而获得对服务器的完全控制。
解决方案：
实施文件类型白名单和内容验证：
任务：废弃黑名单，改为白名单验证，并增加基于文件内容的真实类型检查。
方案：
定义一个严格的允许上传的文件扩展名白名单（例如{"jpg", "png", "gif", "pdf", "docx"}）。
拒绝任何扩展名不在白名单或真实MIME类型与扩展名不符的文件。
对上传文件进行重命名和安全存储：
任务：停止使用原始文件名，并将文件存储在Web根目录之外。
方案：
为每个上传的文件生成一个唯一的、随机的文件名（例如使用UUID），并且不包含任何原始文件名中的信息。
在配置文件中强制要求weeb.upload.base-path指向一个位于Web应用部署目录之外的路径。
当用户需要访问文件时，通过一个专门的控制器端点（例如GET /api/files/download/{fileId}）来提供服务。该端点应先进行权限检查，然后从安全位置读取文件并作为数据流返回给用户，同时设置正确的Content-Disposition头。
粗粒度的访问控制：SecurityConfig.java中的授权规则完全基于URL模式和简单的角色字符串（ROLE_USER, ROLE_ADMIN）。例如，requestMatchers("/admin/**").hasRole("ADMIN")将整个/admin/路径下的所有权限都赋予了管理员。这种模式在应用功能复杂化后会迅速变得难以管理。例如，如果需要一个“内容版主”角色，他可以删除文章但不能删除用户，现有的模型就无法轻易实现。一个真正的RBAC（Role-Based Access Control）模型应该将权限（Permission，如article:delete）与角色（Role）解耦，角色是一系列权限的集合，而用户则被赋予一个或多个角色 。
解决方案：
引入完整的RBAC模型：
任务：重构安全模型，引入权限、角色和用户-角色的多对多关系。
方案：
数据库设计：创建permissions表（如id, name）、roles表（如id, name）以及role_permission和user_role两个中间表。
权限定义：在代码中定义细粒度的权限字符串，例如ARTICLE_CREATE, ARTICLE_DELETE_OWN, ARTICLE_DELETE_ANY, USER_BAN等。
重构SecurityConfig：使用Spring Security的@PreAuthorize或@PostAuthorize注解在方法级别进行权限检查，替代原有的URL匹配。例如：@PreAuthorize("hasAuthority('ARTICLE_DELETE_ANY') or (hasAuthority('ARTICLE_DELETE_OWN') and @articleSecurityService.isOwner(principal, #articleId))")。
创建权限管理后台：开发一个管理员界面，用于创建角色、为角色分配权限以及为用户分配角色。
4.1. 核心实时聊天功能严重缺失
项目在实时通信方面的实现与其在README.md文档中的承诺存在巨大鸿沟。许多被描述为核心特性的功能在当前代码中完全缺失，导致其实际用户体验远未达到“现代化即时通信系统”的标准。

待办任务：实现README.md中承诺的关键实时聊天功能

问题分析：

README.md文件为用户描绘了一幅功能丰富的实时聊天图景，其中包括“打字指示器”、“消息状态 (发送中/已发送/已送达/已读)”、“消息撤回”和“消息反应”等 。这些功能是现代IM应用（如Slack, Discord, WhatsApp）的标配，对营造流畅、自然的交流体验至关重要。  

然而，对WebSocketHandler.java的深入分析表明，当前的WebSocket后端实现极为初级 。它仅能处理三种类型的消息：  

auth：用于用户连接时的身份认证。

chat：用于在用户之间转发基本的文本消息。

heartbeat：用于维持连接的心跳检测。

代码中完全没有处理“用户正在输入”、“消息已送达”、“消息已被阅读”等事件的逻辑，也没有定义相应的WebSocket消息类型。虽然数据库层面存在message_reaction表和is_recalled字段，但这些状态变更并未通过WebSocket进行实时广播，用户无法实时感知这些变化。

这种文档与实现之间的脱节，可能源于团队对实现这些实时功能的复杂性估计不足，尤其是在选择了底层的Netty框架之后。这不仅误导了项目干系人对项目成熟度的判断，也意味着产品的核心竞争力尚未形成。

README.md 实时功能实现情况对比

README.md 承诺功能	实现状态	代码证据/分析 (WebSocketHandler.java)	建议行动
打字指示器	未实现	WebSocketHandler中没有处理"typing"或类似事件的逻辑。	定义TYPING_START和TYPING_STOP WebSocket消息类型，并实现广播逻辑。
消息状态 (已送达/已读)	未实现	WebSocketHandler仅负责转发消息，没有实现消息送达确认和已读回执的协议。	实现客户端到服务器的MESSAGE_DELIVERED和MESSAGE_READ确认消息，并广播给相关方。
消息撤回	部分实现 (非实时)	数据库message表有is_recalled字段，但WebSocketHandler没有广播撤回通知的逻辑。	定义MESSAGE_RECALL WebSocket消息类型，当消息被撤回时，向相关会话的所有客户端广播此事件。
消息反应 (表情等)	部分实现 (非实时)	数据库有message_reaction表，但WebSocketHandler没有广播反应更新的逻辑。	定义MESSAGE_REACTION_UPDATE WebSocket消息类型，当反应变化时，向会话广播更新后的反应状态。
表情包支持	未实现	当前chat消息仅处理简单文本内容，没有对自定义表情或Sticker的支持。	扩展消息内容格式（如JSON），支持emoji或sticker类型，并由客户端进行相应渲染。

Export to Sheets
解决方案：

扩展WebSocket消息协议：

任务：在WsContentType.java或类似常量类中，定义一套完整的消息类型来支持缺失的功能。

方案：至少应添加以下类型：TYPING_START, TYPING_STOP, MESSAGE_DELIVERED, MESSAGE_READ, MESSAGE_RECALL, REACTION_ADD, REACTION_REMOVE。

在WebSocketHandler中实现新事件的处理逻辑：

任务：为每种新的消息类型添加相应的处理逻辑。

方案：

打字指示器：当收到TYPING_START时，向会话中的其他用户广播该事件。收到TYPING_STOP时同理。

已读回执：当用户A收到用户B发送的MESSAGE_READ确认（包含被读消息的ID）时，服务器需要将该事件通知给用户B。

消息撤回/反应：当通过REST API（或WebSocket命令）触发消息撤回或反应变更后，MessageService应通过WebSocketService向该会话的所有在线成员广播一个包含更新信息的消息。

4.2. 缺失标准的协作与社交功能
除了基础的实时通信功能外，项目还缺少一系列在现代协作和社交平台中被视为标准配置的功能。这些功能的缺失，使得WEEB作为一个“团队协作和内容创作”平台，其核心价值大打折扣。

待办任务：规划并实现关键的协作与社交功能

问题分析：

通过对项目代码库的全面审查 ，并与主流协作平台（如Slack）和社交平台（如Discord）的功能集进行对比 ，可以发现以下关键功能的缺失：  

消息线索/回复 (Threads)：在群聊中，针对某一条特定消息进行回复是组织对话、避免信息混乱的核心功能。当前项目数据库的message表中虽然有一个reply_to_message_id字段 ，但这仅能支持简单的引用式回复，无法形成独立的消息线索（Thread），所有回复依然会混杂在主频道中。  

用户提及 (@-mentions)：在群聊中通过@username来特别通知某个成员是协作沟通的基础。当前系统没有实现提及用户的解析、存储和通知机制。

富链接预览 (Link Unfurling)：当用户在聊天中分享一个URL时，现代IM工具会自动抓取该链接的元数据（标题、描述、预览图）并生成一个卡片式预览。此功能可以极大地丰富交流内容，但WEEB目前并未实现。

自定义用户状态：UserOnlineStatus.java中定义的状态仅限于“在线”、“离线”、“离开”、“忙碌”四种 。主流平台允许用户设置自定义状态消息（如“会议中”、“外出就餐”），这为团队成员提供了更丰富的上下文信息。  

这些功能的缺失，表明项目的设计可能更多地停留在“聊天工具”的层面，而未能深入理解“协作平台”或“社区平台”的本质。后者强调的是信息的组织、上下文的保留以及成员之间的高效互动。没有这些功能，WEEB难以在竞争激烈的市场中吸引和留住习惯了丰富交互体验的用户。

解决方案：

实现消息线索功能：

任务：重构消息模型和UI，以支持线程化回复。

方案：

后端：在message表中增加一个thread_id字段。对于一条新的主消息，thread_id可以为其自身的id。所有对该消息的回复，都共享相同的thread_id。

前端：在UI中为每条消息添加“回复”按钮。点击后，打开一个侧边栏或独立的视图，专门显示该thread_id下的所有消息。主聊天窗口中仅显示对主消息的回复数量。

开发用户提及功能：

任务：实现@username的解析、通知和高亮显示。

方案：

前端：在输入框中实现@触发的用户列表自动补全。

后端：在发送消息时，后端需要解析消息内容中的@username，识别出被提及的用户ID。在message表中增加一个字段（如mentioned_user_ids）来存储这些ID。同时，触发NotificationService，为被提及的用户创建一条“您被提及”的通知。

集成链接预览服务：

任务：当消息内容包含URL时，自动生成预览卡片。
方案：当MessageService检测到消息中含有URL时，异步调用一个微服务或后台任务。该任务负责抓取URL内容，解析其HTML中的Open Graph标签（或<title>, <meta name="description">等），并将解析出的标题、描述和图片URL存回message表的一个新JSON字段中（如link_preview_data）。前端根据此数据显示预览卡片。
4.3. 缺乏必要的管理后台与用户安全中心
项目目前完全没有提供任何形式的管理后台或用户安全中心界面。这对于一个计划投入生产环境的平台来说是不可接受的，它意味着系统缺乏有效的管理、监控和用户自助服务能力。
待办任务：开发后台管理系统和用户安全中心
问题分析：
无管理后台 (Admin Panel)：对整个代码库的审查显示，项目中不存在任何用于后台管理的控制器、服务或前端组件 。这意味着所有管理操作，如：  
用户管理：封禁违规用户、重置用户密码、修改用户角色。
内容审核：删除违规文章、评论或消息。
群组管理：解散群组、转移群主。
系统监控：查看用户增长、活跃度、服务器状态等统计数据。
都必须由技术人员直接操作数据库或服务器来完成。这不仅效率低下，而且极易引发操作失误，同时还违反了最小权限原则，因为执行这些操作的人员需要过高的系统权限。
无用户安全中心：用户在个人设置中，除了修改基本资料外，没有任何管理账户安全的选项。主流平台通常会提供一个“安全中心”，允许用户执行以下操作 ：
查看当前所有已登录的会话（包括设备、IP地址、登录时间）。
强制登出所有其他设备。
查看最近的登录历史和安全事件（如密码修改）。
启用/禁用双因素认证（2FA）。
这些功能是建立用户信任、帮助用户在账户疑似被盗时进行自救的关键。
这种缺失反映了典型的“功能优先，运营滞后”的开发模式。团队专注于构建面向最终用户的功能，而完全忽略了系统上线后进行日常运营和维护所必需的工具。这会给未来的运营团队带来巨大的负担，并使用户在面临安全问题时感到无助。
解决方案：
规划并分阶段开发管理后台：
任务：为管理员和运营人员创建一个基于Web的管理后台。
方案
技术选型：可以利用现有的Vue技术栈，创建一个独立的前端应用，或者使用成熟的后台框架（如Vue-Element-Admin）来快速搭建。
API开发：在后端创建一套新的、仅限管理员访问的RESTful API（例如，置于/api/v1/admin/路径下），用于执行用户管理、内容审核等操作。这些API必须受到严格的权限保护（仅ROLE_ADMIN可访问）。
功能优先级：优先开发最核心的管理功能：用户搜索与封禁、内容删除。然后逐步增加角色管理、数据统计报表等高级功能。
在用户设置中增加“安全中心”模块：
任务：为用户提供管理账户安全的功能。
方案：
后端支持：
在Redis中记录用户的活动会话，每个会话包含JWT标识、IP地址、User-Agent和最后活动时间。
提供API端点用于查询当前用户的所有活动会话，以及强制登出特定或所有会话（通过将Redis中的相关JWT加入黑名单）。
使用SecurityAuditUtils记录所有安全敏感操作（登录、密码修改等），并提供API查询这些日志。
前端开发：在用户个人中心页面下，创建一个新的“安全设置”或“账户安全”标签页，用于展示会话列表、登录历史，并提供相应的操作按钮。
V. 代码质量与可维护性问题
本节关注代码库中存在的、影响长期健康发展的问题。这些问题虽然不直接构成安全漏洞或功能缺失，但会增加维护成本、降低开发效率，并可能在未来演变成更严重的缺陷。
5.1. 存在已废弃和冗余的代码
代码库中包含已被明确标记为废弃或已无实际功能的类，这些“僵尸代码”构成了不必要的技术债务，对新加入的开发者造成困扰，并增加了代码库的认知负荷。
待办任务：清理项目中的废弃和冗余代码
问题分析：
功能已移除但代码残留：AiChatService.java被明确标记为@Deprecated，注释中写道“AI聊天功能已彻底移除” 。然而，这个类文件依然存在于项目中。虽然它目前是一个空类，但它的存在会误导开发者，使其认为AI功能可能仍然以某种形式存在或计划回归。
API已更新但旧版并存：如前文所述，ChatListController.java已被@Deprecated注解标记，注释指示应使用新的ChatController 。但该旧控制器并未被禁用或移除，其API端点依然有效。这会造成新开发者在维护或开发新功能时，可能误用旧的、即将被淘汰的API，从而引入缺陷。
这种现象表明团队缺乏严格的代码卫生（Code Hygiene）和重构纪律。一个功能或模块的生命周期不仅包括开发和部署，也应包括在其被取代时的清理和移除。未能完成这最后一步，反映出一种“只增不减”的开发文化，长此以往，项目将变得臃肿不堪，充满了无人理解和不敢触碰的“历史遗留代码”。
解决方案：
执行代码清理计划：
任务：在下一次迭代中，分配专门的时间来清理已知的废弃代码。
方案：
安全移除AiChatService.java：全局搜索项目中对AiChatService的引用。由于它是一个空类，很可能没有实际引用。确认无引用后，直接从版本控制中删除该文件。
安全移除ChatListController.java：
首先，在控制器层面禁用其所有端点，例如通过注释掉@RestController注解或在SecurityConfig中明确拒绝访问其路径。
部署此变更后，监控API网关或服务器日志，确认在一段时间内（例如一到两周）没有任何对旧端点的调用。
确认无调用后，从版本控制中删除ChatListController.java及其相关的服务和DTO（如果它们也仅为该控制器服务）。
5.2. 异常处理机制不一致
项目虽然引入了全局异常处理器这一良好实践，但在具体的控制器实现中却未能统一遵循，存在大量手动的、重复的异常捕获逻辑，这破坏了代码的一致性和可维护性。
待办任务：统一异常处理逻辑，充分利用全局异常处理器
问题分析：
项目中存在一个GlobalExceptionHandler.java文件，它使用了@RestControllerAdvice注解 。这是一个Spring MVC的高级功能，旨在集中捕获应用程序中所有控制器抛出的异常，并将其转换为统一的、标准化的HTTP响应（在本项目中是ApiResponse对象）。这是一种非常好的设计，能够将业务逻辑与错误处理逻辑解耦。  
然而，在AuthController.java等控制器中，大量的方法内部包含了try-catch (RuntimeException e)块 。在catch块中，代码手动构建了一个ResponseEntity<ApiResponse>错误响应并返回，例如：
return ResponseEntity.badRequest().body(ApiResponse.error(1, e.getMessage()));
这种做法完全违背了使用@RestControllerAdvice的初衷，并导致了以下问题：
代码冗余：每个控制器方法中都重复着几乎相同的try-catch模板代码。
不一致的错误响应：手动构建的错误响应可能与GlobalExceptionHandler中定义的格式、状态码或消息结构不完全一致。
信息泄露风险：直接将e.getMessage()返回给客户端，可能会泄露系统内部的实现细节或敏感信息，为攻击者提供线索。GlobalExceptionHandler通常会记录详细的内部错误，但只向客户端返回一个通用的、安全的消息。
这种现象通常被称为“货物崇拜编程”（Cargo Cult Programming）：开发团队引入了一个先进的模式（全局异常处理），但并未完全理解其工作原理和设计哲学，因此仍然沿用着旧的、在每个方法中手动处理异常的习惯。这导致一个本应简化代码、提升健壮性的优秀特性被 фактически架空。
解决方案：
重构所有控制器，移除手动异常处理：
任务：审查项目中所有的@RestController，移除方法内部的try-catch块，让异常自然地向上抛出。
方案：将控制器方法简化，专注于业务逻辑调用。例如，将以下代码：
Java
// AuthController.java (修改前)
@PostMapping("/login")
public ResponseEntity<ApiResponse<Map<String, String>>> login(@RequestBody @Valid LoginVo loginVo) {
    try {
        String token = authService.login(loginVo.getUsername(), loginVo.getPassword());
        Map<String, String> data = new HashMap<>();
        data.put("token", token);
        return ResponseEntity.ok(ApiResponse.success(data));
    } catch (RuntimeException e) {
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(ApiResponse.error(1, e.getMessage()));
    }
}
重构为：
Java
// AuthController.java (修改后)
@PostMapping("/login")
public ApiResponse<Map<String, String>> login(@RequestBody @Valid LoginVo loginVo) {
    String token = authService.login(loginVo.getUsername(), loginVo.getPassword());
    Map<String, String> data = new HashMap<>();
    data.put("token", token);
    return ApiResponse.success(data);
}
在AuthService.login方法中，如果验证失败，应抛出特定的自定义异常（例如AuthenticationFailedException），而不是通用的RuntimeException。
增强GlobalExceptionHandler：
任务：在GlobalExceptionHandler中为业务相关的自定义异常添加专门的处理方法。
方案：为不同的业务场景创建具体的、继承自RuntimeException的异常类，如UserNotFoundException, InvalidPasswordException, AccountLockedException等。然后在GlobalExceptionHandler中为这些异常编写对应的@ExceptionHandler方法，返回更精确的HTTP状态码和错误信息。
Java
// GlobalExceptionHandler.java (增强后)
@ExceptionHandler(InvalidPasswordException.class)
public ResponseEntity<ApiResponse<Object>> handleInvalidPasswordException(InvalidPasswordException e) {
    //... 记录日志
    return new ResponseEntity<>(ApiResponse.unauthorized("用户名或密码错误"), HttpStatus.UNAUTHORIZED);
}
@ExceptionHandler(AccountLockedException.class)
public ResponseEntity<ApiResponse<Object>> handleAccountLockedException(AccountLockedException e) {
    //... 记录日志
    return new ResponseEntity<>(ApiResponse.forbidden("账户已被锁定"), HttpStatus.FORBIDDEN);
}
通过以上重构，可以确保所有异常都由一个中心点统一处理，从而简化控制器代码，保证错误响应的一致性，并提高系统的整体安全性和可维护性。