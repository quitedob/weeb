本项目是一个前后端分离的应用, 前端使用Vue 3.5.13, 后端使用Java Spring Boot 3.5.4.
核心设计理念是分层清晰, 职责单一, 接口标准化, 高内聚低耦合.
项目采用微服务架构思想，包含即时通信、内容管理、AI对话等核心功能模块.
所有开发人员必须严格遵守本规范，并且写不完的请写在todo.txt中，写出哪个文件和模块和功能没实现，具体要怎么实现

=== 端口配置规范 ===
1. 后端API服务端口：8080 (application.yml中配置)
2. WebSocket服务端口：8081 (application.yml中配置)
3. 前端开发服务器默认端口：5173 (Vite默认)
4. 严禁随意修改端口配置，如需修改必须更新所有相关文件
5. 修改端口后必须同步更新axiosInstance.js中的API基础URL
6. 端口冲突时优先处理占用端口的进程，而不是修改应用端口

=== 后端开发规范 ===
1. 项目使用MySQL 8.0+数据库和MyBatis-Plus 3.5.8持久层框架
2. 后端遵循多层架构模型, 数据流向为 Controller, Service, Mapper, Database
3. Controller层是API的入口, 负责接收HTTP请求, 使用@Valid注解校验参数, 并调用Service层
4. Controller层严禁编写复杂业务逻辑, 所有接口返回ResponseEntity<ApiResponse<T>>
5. 接收请求必须使用com.web.vo包下的VO对象封装请求体
6. Service层采用接口加实现的设计模式, 接口位于com.web.service包, 实现位于com.web.service.Impl包(注意是大写的I(impl))
7. 涉及多张表读写的复杂数据库操作, 必须在ServiceImpl的方法上使用@Transactional注解
8. 修改ServiceImpl中的方法签名, 必须立即同步更新其对应的Service接口
9. Mapper层采用接口加XML的方式, Mapper接口位于com.web.mapper包, XML文件位于resources/Mapper目录
10. Mapper接口的方法名必须与XML中statement的id一致, @Param注解的参数名必须与XML中的引用严格匹配
11. 新增功能模块必须包含完整的Controller、Service、ServiceImpl、Mapper、VO、Model结构
12. AI相关功能统一使用AiChatService，遵循统一的AI接口规范
13. SSH终端功能统一通过CommandManager管理，确保安全性和可追踪性

=== 数据库规范 ===
1. 位于com.web.model包的实体类与数据库表一一对应
2. User表和UserStats表的分离设计是为了避免高并发下的写锁竞争
3. User表存储低频更新信息, UserStats表存储高频更新的统计信息
4. DatabaseInitializer.java会在非生产环境自动创建库和表
5. user表和user_stats表分离是关键性能设计, 开发涉及用户统计数据的功能时, 必须操作user_stats表
6. 业务逻辑错误应抛出自定义的WeebException
7. GlobalExceptionHandler会统一捕获异常并以标准化的ApiResponse格式返回给前端

=== 前端开发规范 ===
1. 前端所有HTTP通信必须通过src/api/axiosInstance.js中封装的axios实例
2. 请求拦截器会自动添加JWT到请求头, 响应拦截器统一处理ApiResponse格式
3. 新的API请求应根据业务领域添加到src/api/modules/目录下的对应模块中
4. 全局状态管理必须使用Pinia, 用户的认证信息由src/stores/authStore.js管理
5. 新功能模块应在src/stores/目录下创建独立的Store文件
6. UI组件库统一使用Element Plus 2.7.8, 全局样式使用src/assets/apple-style.css中定义的CSS变量
7. 所有页面路由在src/router/index.js中定义, 需要认证的页面应添加meta, { requiresAuth: true }
8. 富文本编辑功能统一使用Quill 2.0.3，遵循统一的编辑器配置规范
9. 视频播放功能统一使用video组件，确保跨浏览器兼容性
10. 新增页面组件必须包含响应式设计，支持移动端适配
11. 组件命名必须使用PascalCase，文件名与组件名保持一致

=== WebSocket开发规范 ===
1. WebSocket连接使用chatStore.js管理, 连接地址: ws://localhost:8081/ws
2. 消息格式必须标准化, 包含type、data、timestamp字段
3. 实时消息同步通过WebSocket实现, HTTP作为备用方案
4. 打字指示器和消息状态通过WebSocket实时传输
5. WebSocket断线重连机制已在chatStore中实现, 不得随意修改

=== 搜索功能规范 ===
1. 消息搜索使用Elasticsearch, 通过SearchController提供API
2. 搜索API路径必须以/api/search/开头
3. 支持多类型搜索: messages、users、groups、articles、all
4. 搜索结果必须包含list和total字段, 支持分页
5. Elasticsearch不可用时, 搜索功能应优雅降级, 不影响核心功能

=== 安全开发规范 ===
1. 所有用户输入必须通过ValidationUtils验证
2. SQL注入防护使用SqlInjectionUtils, 严禁直接拼接SQL
3. 安全事件通过SecurityAuditUtils记录, 包括登录失败、异常操作等
4. JWT Token管理通过authStore.js, 过期自动刷新
5. 敏感信息必须使用环境变量配置, 不得硬编码
6.禁止使用select * 等操作

=== 本地开发健康规范 ===
1. 开发环境启动前必须确保MySQL、Redis、Elasticsearch服务正常运行
2. 数据库连接失败时优先检查服务状态和网络连接，避免频繁修改配置
3. 使用mvn spring-boot:run启动后端，使用npm run dev启动前端
4. 定期清理日志文件，避免日志文件过大影响开发环境性能
5. 本地开发时启用调试模式，设置环境变量DEBUG=true
6. Git提交前必须执行代码格式化和静态检查
7. 开发过程中遇到问题优先查看控制台日志和错误信息
8. 定期更新依赖包版本，确保安全性和性能
9. 开发完成后必须进行基础功能测试，确保核心功能正常
10. 遵循Git Flow工作流，feature分支开发完成后及时合并到develop分支

=== 文档更新规范 ===
1. 修改重要功能后必须同步更新README.md
2. API接口变更必须更新文档中的接口列表
3. 端口配置变更必须更新README.md中的访问应用部分
4. 新增功能必须更新README.md中的核心功能部分
5. 技术架构变更必须更新README.md中的技术栈部分
6. 依赖版本变更必须同步更新README.md中的技术栈信息
7. 新增开发规范必须更新rule.txt文件
8. 项目结构变更必须更新README.md中的项目结构说明

=== 代码修改禁止事项 ===
1. 严禁随意修改端口配置而不更新相关文件
2. 严禁绕过安全验证和输入检查
3. 严禁直接在Controller层编写复杂业务逻辑
4. 严禁不使用事务进行多表操作
5. 严禁不通过统一的API封装进行HTTP请求
6. 严禁修改核心架构设计模式
7. 严禁提交包含安全隐患的代码

=== API架构统一规范 ===
1. 严禁创建功能重叠的API端点，所有API必须遵循单一职责原则
2. 聊天功能统一使用/api/chats/*路径，废弃/api/v1/chats、/api/v1/message、/api/threads
3. 用户信息获取统一使用/api/users/me端点，废弃跨域调用如/api/articles/userinform-by-username
4. 新增API必须进行架构评审，确保不产生冗余和混乱
5. API版本管理统一使用/api/v2/*前缀，新功能必须使用新版本
6. 所有API变更必须同步更新backend.md文档

=== 权限系统统一规范 ===
1. 权限系统严格遵循RBAC模型，禁止使用UserLevel.java中的硬编码权限
2. 权限初始化统一由SystemSecurityInitializer管理，禁止分散在多个文件中
3. 所有权限常量必须在Permissions.java中定义，不允许直接使用字符串
4. 角色和权限数据统一通过数据库迁移工具管理，不允许SQL脚本直接操作
5. 权限变更必须经过安全评审，确保不产生安全漏洞
6. 生产环境权限配置必须通过环境变量控制

=== 数据库管理规范 ===
1. 禁止使用DatabaseInitializer的自动重建功能，必须使用Flyway/Liquibase
2. 数据库模式变更必须通过版本化的迁移脚本进行
3. 开发环境数据丢失问题必须通过备份和恢复机制解决
4. 数据一致性问题必须通过事务和后台校准任务解决
5. 反规范化字段必须有对应的同步机制
6. 数据库性能优化必须通过索引和查询优化实现

=== 代码质量与重构规范 ===
1. 所有linter警告必须在提交前清理，目标是0个警告
2. Service接口与实现必须保持严格一致，修改签名必须同步
3. 占位符逻辑必须替换为真实实现，不允许提交伪功能
4. 代码重复必须通过重构消除，遵循DRY原则
5. 单元测试覆盖率必须达到80%以上，新功能必须包含测试
6. 代码审查必须包含架构一致性检查

=== 前端架构优化规范 ===
1. 禁止跨领域API调用，所有组件必须使用正确的领域接口
2. 认证状态管理必须支持跨标签页同步和自动刷新
3. HTTP请求重试必须仅针对瞬态错误，禁止重试业务错误
4. API契约必须严格执行，前端不得依赖后端实现细节
5. 组件必须遵循领域边界，不得混合不同模块的逻辑
6. 状态管理必须集中化，禁止组件内部维护全局状态

=== 搜索功能统一规范 ===
1. 所有搜索功能必须使用统一的SearchService接口
2. Elasticsearch必须作为主要搜索后端，数据库LIKE查询仅作为降级方案
3. 搜索API必须支持统一的参数格式和响应结构
4. 搜索索引必须实时同步，数据一致性有保障
5. 搜索功能降级策略必须明确定义

=== 项目重构规范 ===
1. 重大架构变更必须制定详细的迁移计划
2. 废弃功能必须标记@Deprecated并制定移除时间表
3. 重构必须分阶段进行，确保系统稳定性
4. 技术债务必须定期清理，不允许积累
5. 重构完成后必须更新所有相关文档

=== 项目未来健康规范 ===
1. 保持代码质量和架构清晰
2. 建立完整的CI/CD流程，自动化测试和部署
3. 建立完整的错误追踪和日志分析体系
4. 定期进行代码审查，确保代码质量和规范性
5. 建立完整的项目文档，包括技术文档、用户文档、运维文档
6. 关注系统可扩展性，为未来功能扩展预留接口和架构空间

=== 违规处理 ===
1. 违反核心架构规范的代码将被拒绝合并
2. 创建冗余API或权限混乱将被立即要求重构
3. 不清理代码质量问题的将被要求整改
4. 跨领域调用将被立即修复
5. 安全漏洞代码将被立即要求修复
6. 多次违反规范的开发者将被移除提交权限
7. 不遵守本地开发健康规范的将被要求整改
8. 代码质量不达标的将被要求重构和优化
9. 影响系统稳定性的变更将被立即回滚
10. 未经过充分测试的功能将被禁止部署到生产环境